Міністерство освіти і науки України

Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА

з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для автоматизованого моніторингу та керування прийомом медикаментів



Студент гр. ПЗПІ-21-5                  _______________ Вальтер А.А.
       (підпис)

Керівник роботи                 _____________ ст.викл. Сокорчук І.П
                                  (підпис)

                         Роботу захищено «__»_______2024 р.
                          з оцінкою ______________________

Комісія:                           _______________ доц. Лещинський В.О.
                                                    (підпис)
                       _______________ доц. Лещинська І.О.
(підпис)
                    _______________ ст.викл. Сокорчук І.П.
(підпис)

Харків
2024 р.
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук	Кафедра програмної інженерії	
Спеціальність 121 – Інженерія програмного забезпечення	
Курс	3	Семестр	6
Навчальна дисципліна Архітектура програмного забезпечення

ЗАВДАННЯ НА ЛАБОРАТОРНІ РОБОТИ СТУДЕНТОВІ
Вальтер Анні Антоніві
1. Тема проекту: «Програмна система для автоматизованого моніторингу та керування прийомом медикаментів» 
2. Термін узгодження завдання з лабораторних робіт: «02» квітня 2024 р. 
3. Термін здачі студентом проекту: «1» червня 2024 р. 
4. Вихідні дані до проекту (роботи): В програмній системі передбачити: реєстрацію та авторизацію користувачів(пацієнтів, медичного персоналу, технічного персоналу); можливість пацієнтам отримати ліки з дозуючого пристрою, використовуючи мобільний додаток або свій унікальний ідентифікатор; зберігання системою даних про прийом ліків пацієнтами для подальшого аналізу медичним персоналом; призначення медичним персоналом системи лікування; доступ до даних про прийом ліків медичному персоналу у реальному часі для швидкого реагування на будь-які відхилення в терапії пацієнтів; функцію надання рекомендацій від медичного персоналу щодо оптимізації терапії на основі аналізу історії прийому ліків та медичних показників пацієнтів; нагадування пацієнтам у мобільний додаток про час наступного прийому ліків; технічний персонал може додавати ліки до автоматичного дозуючого пристрою через систему; функцію ведення електронного медичного журналу з історією прийому ліків та іншою медичною інформацією, що буде доступна пацієнтам та медичному персоналу; моніторингу стану дозуючого пристрою у реальному часі з можливістю відстеження стану запасів ліків та виконання технічних підтримуючих дій для технічного персоналу; функцію планування заповнення дозуючого пристою з урахуванням потреб пацієнтів та рекомендацій медичного персоналу; у якості IoT в свою чергу буде присутній дозуючий пристрій; докладніше про вхідні дані до проекту наведено у Vision and Scope. 
5. Зміст звітів з лабораторних робіт (перелік питань, що належить розробити): Лабораторна робота №1 – розробити аркуш завдання та описати проект у форматі Vision & Scope. 
Лабораторна робота №2 – розробити серверну / back-end частину програмної системи. 
Лабораторна робота №3 – розробити програмну частину для IoT пристрою (Arduino). 
Лабораторна робота №4 – розробити клієнтську / front-end частину програмної системи. 
Лабораторна робота №5 – розробити мобільний програмний застосунок для мобільної платформи Android. 
6. Перелік графічного матеріалу: 
UML діаграма розгортання (Deployment Diagram), UML діаграма прецедентів  (Use Case Diagram), ER-модель даних (Entity–Relationship Model), UML діаграма взаємодії (Interaction Overview Diagram), UML діаграму діяльності (Activity Diagram), UML діаграма компонент (Component Diagram). 
 

КАЛЕНДАРНИЙ ПЛАН

№	Назва етапу	Термін виконання	Примітка
1	Vision & Scope	06.04.2024	виконано
2	Серверна частина / Back-end	20.04.2024	виконано
3	IoT програмний застосунок	04.05.2024	
4	Клієнтська частина / Front-end	18.05.2024	виконано
5	Мобільний застосунок	01.06.2024	виконано

Дата видачі теми проєкту «02» квітня 2024 р.

Викладач лабораторних робіт _______ ст. вик. каф. ПІ Сокорчук І.П.
	      				(підпис)


Завдання прийняла до виконання ст.гр. ПЗПІ-21-5__________Вальтер А.А.
	      							   (підпис)
 
РЕФЕРАТ
Пояснювальна записка до курсової роботи: 67 с., 34 рис., 1 табл., 11 додатків, 4 джерел.
АВТОМАТИЗАЦІЯ ПРИЙОМУ ЛІКІВ, МОНІТОРИНГ ПРИЙОМУ ЛІКІВ, ДОЗУЮЧИЙ ПРИСТРІЙ, ПІДВИЩЕННЯ ТОЧНОСТІ ДОЗУВАННЯ, МЕДИЧНА ІНФОРМАЦІЙНА СИСТЕМА

Об’єктом розробки є програмна система для автоматизованого моніторингу та керування прийомом медикаментів.
Мета курсової роботи – проектування та розробка серверної,  клієнтської та мобільної частини системи  для. автоматизованого моніторингу та керування прийомом медикаментів.
Методи розробки – середовища розробки Visual Studio та Visual Studio Code. Для розробки серверної частини було використано мову програмування C#, технологію ASP.NET Core та систему управління базами даних PostgreSQL. Клієнтський застосунок побудовано за допомогою технології Angular та  мови програмування Typescript. Для мобільного застосунку було використано мову програмування C# та платформу для розробки мобільних застосунків .Net MAUI.
В результаті роботи було створено серверну, клієнтську та мобільні частини системи для автоматизованого моніторингу та керування прийомом медикаментів.

 
ЗМІСТ

ВСТУП	8
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ	9
1.1	Аналіз ринку та можливості для бізнесу	9
1.2	Вимоги до частин системи	10
2 РОЗРОБКА СЕРВЕРНОЇ ЧАСТИНИ ПРОЕКТУ	12
2.1 Опис архітектури системи	12
2.2 Побудова діаграми розгортання	13
2.3 Побудова ER-діаграми	13
2.4 Опис архітектури серверної частини	14
2.4.1 Створення бази даних та робота з даними	14
2.4.2 Використання CQRS, MediatR та контролерів	16
2.4.3 Обробка помилок	19
2.4.5 Можливість адміністрування системи	21
2.4.6 Локалізація	21
2.4.7 Інтернаціоналізація	22
2.4.8 Облік часу	22
2.4.9 Захист даних	23
2.5 Побудова діаграми прецедентів	23
2.6 Специфікація REST	23
2.7 Побудова діаграми прецедентів	28
2	РОЗРОБКА ВЕБ ЧАСТИНИ ПРОЕКТУ	29
3.1 Опис архітектури веб частини	29
3.2 Реалізація веб-частини системи	30
3.2.1 Авторизація та управління доступом користувачів	30
3.2.2 Обробка помилок	32
3.2.3 Можливість адміністрування системи	35
3.2.4 Інтернаціоналізація	38
3.2.5 Бізнес логіка	39
3.2.6 Локалізація	41
3.2.7 Облік часу	42
4 РОЗРОБКА МОБІЛЬНОЇ ЧАСТИНИ ПРОЕКТУ	43
4.1 Опис архітектури мобільної частини	43
4.2 Реалізація мобільної частини системи	44
4.2.1 Авторизація та управління доступом користувачів	44
4.2.2 Бізнес логіка	45
4.2.3 Локалізація	48
ВИСНОВКИ	49
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	50
ДОДАТОК А	51
ДОДАТОК Б	54
ДОДАТОК В	56
ДОДАТОК Г	57
ДОДАТОК Д	58
ДОДАТОК Е	59
ДОДАТОК Ж	60
ДОДАТОК К	61
ДОДАТОК Л	64
ДОДАТОК М	65
ДОДАТОК Н	66


ВСТУП


У сучасному медичному середовищі, особливо у лікарнях та медичних установах, існує необхідність вдосконалення системи контролю та моніторингу прийому ліків пацієнтами. Зараз багато ліків видаються у ручному режимі, що може призводити до помилок у прийомі, неправильної дозування або пропуску деяких ліків. Це може мати серйозні наслідки для здоров'я пацієнтів та спричиняти ускладнення в лікуванні.
Головною ідеєю та метою розробки програмного продукту "Програмна система для автоматизованого моніторингу та керування прийомом медикаментів" є створення ефективного засобу для автоматизації та поліпшення процесу прийому ліків пацієнтами у медичних установах. Цей програмний продукт спрямований на забезпечення надійного контролю за прийомом ліків, підвищення точності дозування, уникнення помилок та забезпечення вчасного та правильного прийому ліків.
Впровадження такої системи дозволить зменшити ризик виникнення небажаних реакцій на ліки, забезпечити дотримання режиму прийому, покращити моніторинг лікування пацієнтів та підвищити загальний рівень якості надання медичної допомоги. Крім того, цей продукт покликаний зробити процес прийому ліків більш зручним і доступним для пацієнтів, що сприятиме підвищенню їхнього задоволення від медичного обслуговування.
 

1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1	Аналіз ринку та можливості для бізнесу


У медичній сфері існує значна потреба в автоматизації та оптимізації процесів прийому ліків пацієнтами. "Програмна система для автоматизованого моніторингу та керування прийомом медикаментів" вирішує цю проблему, надаючи ефективний і зручний інструмент для моніторингу та контролю за прийомом ліків.
На ринку на даний момент існує система "medDispense", що надає схожі послуги у цій сфері, але після детального її аналізу було визначено, що система спрямована на автоматизацію процесу отримання ліків медичним персоналом та їх розподіл між пацієнтами, але не надає можливості прямого самостійного використання пацієнтами. У порівнянні з цим, наша система розробляється з фокусом на розширення функціональності, забезпечуючи можливість використання як медичним персоналом, так і пацієнтами. Вона дозволяє пацієнтам самостійно отримувати необхідні ліки, користуючись персональним кодом чи ідентифікатором, що забезпечує більшу гнучкість та зручність в процесі прийому медикаментів. Такий підхід робить нашу систему більш доступною та корисною для широкого кола користувачів, сприяючи поліпшенню якості медичного обслуговування та забезпечуючи більш ефективний процес лікування.
З розумних дозуючих пристроїв на ринку можна відзначити "Hero", який призначений для використання однією людиною вдома. У порівнянні з "Hero", нова система розроблена з урахуванням потреб взаємодії з великою кількістю користувачів у медичних закладах. Тоді як "Hero" орієнтований на індивідуальне використання, розроблювана система спрямована на оптимізацію процесу прийому ліків у медичних установах, забезпечуючи зручний доступ до медикаментів для великої кількості пацієнтів та сприяючи моніторингу та керуванню прийомом ліків медичним персоналом. Такий підхід робить нашу систему більш адаптованою до потреб медичних установ та забезпечує її ефективність у великих масштабах.
Майбутня модель монетизації передбачає використання абонентської плати з пацієнтів. Користувачі матимуть можливість обирати між стандартною безкоштовною та преміум підпискою в залежності від їхніх потреб та обсягу функціональності, яку вони потребують. Стандартна безкоштовна підписка буде надавати базовий доступ до системи. Користувачі зможуть створювати облікові записи, авторизуватися в системі безкоштовно та матимуть можливість використовувати систему для отримання ліків за допомогою свого персонального коду чи ідентифікатора. Функція ведення журналу прийому ліків та зберігання інформації про час та дозу ліків буде доступна без оплати. Преміум користувачі матимуть можливість налаштовувати індивідуальні нагадування про час прийому ліків через застосунок та матимуть можливість інтегрувати дані про прийом ліків у свій електронний медичний журнал та календар для зручного моніторингу свого здоров'я та лікування. Крім того пацієнти з преміум підпискою отримають доступ до додаткового функціоналу, такого як покращена аналітика за даними про прийом ліків та інші розширені функції.
Окрім цього, можливі варіанти партнерства з медичними установами та іншими компаніями медичного сектору.


1.2	Вимоги до частин системи


Перший реліз буде включати в себе наступну функціональність:
Серверна частина:
–	реєстрація та авторизація користувачів;
–	забезпечення захисту персональних даних, хешування паролів;
–	додавання інформації про пацієнта, редагування та видалення цієї інформації; 
–	додавання інформації про список ліків, дозу та частоту прийому редагування та видалення цієї інформації; 
–	зберігання та обробка даних про прийом ліків пацієнтами для подальшого аналізу;
–	відстеження запасів ліків;
–	функціональність для адміністрування користувачів, ресурсів та налаштувань системи;
–	експорт та імпорт користувацьких даних.
Клієнтська частина:
–	надання відповідних форм для введення особистих даних для реєстрації та авторизації;
–	локалізація (забезпечення можливості обрати українську чи англійську мову інтерфейсу); 
–	перегляд рекомендацій та нагадувань щодо прийому ліків;
–	доступ до функцій системи через веб-інтерфейс;
–	надання інтерфейсу для адміністрування даних;
–	надання інтерфейсу для експорту та імпорту користувацьких даних.
Мобільний застосунок:
–	надання відповідних форм, введення даних у які дозволить здійснювати процеси реєстрації та авторизації;
–	локалізація (забезпечення можливості обрати українську чи англійську мову інтерфейсу); 
–	отримання нагадувань про прийом ліків та рекомендацій медичного персоналу;
–	перегляд графіку прийому медикаментів на день/тиждень;
–	можливість скористатися унікальним ідентифікатором для отримання ліків.
 
2 РОЗРОБКА СЕРВЕРНОЇ ЧАСТИНИ ПРОЕКТУ
2.1 Опис архітектури системи


Архітектура системи MediSync ґрунтується на чотирьохрівневій архітектурі та принципах Domain Driven Design. 
MediSync.Presentation рівень, що відповідає за представлення користувацького інтерфейсу та взаємодію з користувачем. Тут знаходяться контролери, які обробляють HTTP запити та відповідають на них згідно з логікою додатку. Вони отримують запити від клієнтів, передають їх на обробку відповідним сервісам з рівня додатку (MediSync.Application), та повертають результати назад клієнтам. ExceptionMiddleware на цьому рівні відповідає за обробку винятків, що виникають в процесі обробки запитів. На цьому ж рівні відбувається налаштування для перевірки JWT токенів та визначення політик доступу.
У MediSync.Application зосереджено на реалізації бізнес-логіки додатку, використовуючи підходи CQRS (Command Query Responsibility Segregation) та Mediator Pattern для управління запитами та командами.
На рівні MediSync.Domain розташовані моделі даних, які представляють сутності домену додатку. Вони відображають структуру та взаємозв'язки між об'єктами в реальному світі, що використовуються в додатку. 
У MediSync.Infrastructure рівень реалізації доступу до даних через Entity Framework Core. Тут також реалізовані сервіси, що відповідають за обробку паролів та генерацію JWT-токенів. Крім того, в MediSync.Infrastructure є реалізації репозиторіїв для кожної сутності. Ці репозиторії використовуються для взаємодії з базою даних через контекст, забезпечуючи операції створення, читання, оновлення та видалення даних. Нарешті, в MediSync.Infrastructure також реалізовано SignalR хаб NotificationHub, який надає можливість відправки повідомлень у реальному часі між клієнтами додатку.
 
2.2 Побудова діаграми розгортання


Система буде складатися з серверної частини, веб додатку, мобільного додатку та розумного пристрою. Компоненти системи відображені на діаграмі розгортання (див. рис. 2.1).

Рисунок 2.1 – Діаграма розгортання


2.3 Побудова ER-діаграми


Після аналізу системи було створено ER діаграму бази даних (див. рис. 2.2).
База даних містить шість таблиць: користувачі («Users»), медичні засоби («Medicines»), призначення медичних засобів пацієнтам («Prescriptions»), записи про прийом медичних засобів пацієнтами («Transactions»), дозуючі пристрої («Dispensers») та інформація про кількість медичних засобів, що зберігаються у дозуючих пристроях («MedicineStocks»). Кожна таблиця має свій власний унікальний ідентифікатор в якості первинного ключа. Таблиці «Prescriptions» та «MedicineStocks» є таблицями для реалізації відношення багато-до-багатьох. 

 
Рисунок 2.2 – ER-модель даних


2.4 Опис архітектури серверної частини
2.4.1 Створення бази даних та робота з даними


Для створення бази даних системи було обрано підхід Entity Framework «Code First», коли база даних створюється автоматично на основі класів, які описані у коді. У шарі моделі даних була створена папка «Entities», де описані сутності бази даних.
Приклад класу, на основі якого було створено таблицю «Users»:
1. namespace Domain.Entities;
2. 
3. public class User : BaseEntity
4. {
5.     public string? Name { get; set; }
6. 
7.     public string? Surname { get; set; }
8. 
9.     public int? Age { get; set; }
10. 
11.     public string Email { get; set; }
12. 
13.     public string Role { get; set; }
14. 
15.     public string? PasswordHash { get; set; }
16. 
17.     public string? PasswordSalt { get; set; }
18. }

Для налаштування та роботи з базою даних було використано Entity Framework. У проекті MediSync була використана система управління базами даних PostgreSQL. 
Після налаштування бази даних я реалізувала патерн проектування «Репозиторій», що використовується для ізоляції бізнес-логіки від способу збереження та отримання даних. 
Спочатку були створені інтерфейси, які визначають методи, що будть реалізовані у відповідному класі репозиторію. Приклад інтерфейсу «IDispenserRepository»:

1. using Application.Dispensers.Commands.CreateDispenser;
2. using Application.Dispensers.Commands.DeleteDispenser;
3. using Application.Dispensers.Commands.UpdateDispenser;
4.using Application.Dispensers.
  Commands.UpdateDispenserTempereture;
5. using Application.Dispensers.Queries.GetDispensers;
6. using Domain.Entities;
7. 
8. namespace Application.Interfaces;
9. 
10. public interface IDispenserRepository : IRepository<Dispenser>
11. {
12. 		Task<int> CreateDispenser(CreateDispenserCommand request,       CancellationToken cancellationToken);
13. 
14.     Task<int> DeleteDispenser(DeleteDispenserCommand request, CancellationToken cancellationToken);
15. 
16.     Task UpdateLocation(UpdateDispenserLocationCommand request, CancellationToken cancellationToken);
17. 
18.           Task UpdateTemperature(UpdateDispenserTemperetureCommand request, CancellationToken cancellationToken);
19. 
20.     Task<List<Dispenser>> GetAllAsync(GetDispensersQuery request, CancellationToken cancellationToken);
21. }

Фактичні деталі реалізації інтерфейсу «IDispenserRepository» знаходяться у класі інтерфейсу «DispenserRepository» (додаток А).  Інтерфейси репозиторіїв та класи їх реалізації були створені для кожного класу, який реалізує таблицю бази даних.


2.4.2 Використання CQRS, MediatR та контролерів


Для реалізації патерна CQRS (Command Query Responsibility Segregation) і управління запитами та командами використовувався пакет MediatR, який надає простий та ефективний спосіб обробки запитів та команд у додатку. У шарі додатків були створені класи запитів та команд, що відповідають за представлення оброблюваних запитів та команд системи.
Наприклад, для роботи з дозуючими пристроями були створені класи запитів та команд:

1. using MediatR;
 2. 
 3. namespace Application.Dispensers.Commands.CreateDispenser
 4. {
 5.     public record CreateDispenserCommand : IRequest<int>
 6.     {
 7.         public string DispensorName { get; set; }
 8. 
 9.         public string Location { get; set; }
10.     }
11. }
1. using MediatR;
 2. 
 3. namespace Application.Dispensers.Queries.GetDispensers
 4. {
 5.     public record GetDispensersQuery : IRequest<List<DispenserResponse>>
 6.     {
 7.         public string? TemperatureUnit { get; set; } = String.Empty;
 8.     }
 9. }

Далі були створені хендлери, що відповідають за обробку конкретних запитів або команд, які надходять до додатку. Вони реалізують логіку взаємодії з даними або виконання бізнес-логіки, пов'язаної з цими запитами та командами. 
	Клас хендлерів, створених для обробки запитів і команд для роботи з дозуючими пристроями можна знайти у додатку Б.
Контролери були створені для кожного сутності та відповідали за обробку HTTP-запитів, передачу їх до відповідних обробників запитів та команд, а також повернення результатів клієнту. Наприклад, контролер для роботи з дозуючими пристроями має наступний вигляд:

1. using Application.Dispensers.Commands.CreateDispenser;
2. using Application.Dispensers.Commands.DeleteDispenser;
3. using Application.Dispensers.Commands.UpdateDispenser;
4. using Application.Dispensers.Queries.GetDispensers;
5. using MediatR;
6. using Microsoft.AspNetCore.Mvc;
7. 
8. namespace Presentation.Controllers
9. {
10.     [Route("api/[controller]")]
11.     [ApiController]
12.     public class DispenserController : ControllerBase
13.     {
14.         private readonly IMediator _mediator;
15. 
16.         public DispenserController(IMediator mediator)
17.         {
18.             _mediator = mediator;
19.         }
20. 
21.         [Authorize(Roles = "admin")]
22.         [HttpPost]
23.         public async Task<IActionResult> AddDispenser([FromBody] CreateDispenserCommand request, CancellationToken cancellationToken)
24.         {
25.             var response = await _mediator.Send(request, cancellationToken);
26.             return Ok(response);
27.         }
28. 
29.         [Authorize(Roles = "admin")]
30.         [HttpDelete("{id}")]
31.         public async Task<IActionResult> DeleteDispenser(int id, CancellationToken cancellationToken)
32.         {
33.             var response = await _mediator.Send(new DeleteDispenserCommand { Id = id }, cancellationToken);
34.             return Ok(response);
35.         }
36. 
37.         [Authorize(Roles = "admin")]
38.         [HttpGet]
39.         public async Task<IActionResult> GetAllDispensers([FromQuery] string? temperatureUnit, CancellationToken cancellationToken)
40.         {
41.             if (temperatureUnit != "C" && temperatureUnit != "F")
42.             {
43.                 return BadRequest("Invalid temperature unit. Please specify 'C' or 'F'.");
44.             }
45. 
46.             var response = await _mediator.Send(new GetDispensersQuery { TemperatureUnit = temperatureUnit}, cancellationToken);
47.             return Ok(response);
48.         }
49. 
50. 
51.		[Authorize(Roles = "admin")]
52.         [HttpPut]
53.         public async Task<IActionResult> UpdateLocation([FromBody] UpdateDispenserLocationCommand request, CancellationToken cancellationToken)
54.         {
55.             var response = await _mediator.Send(request, cancellationToken);
56.             return Ok(response);
57.         }
58.     }
59. }


2.4.3 Обробка помилок


Перед тим, як потрапити до контролера запити обробляються ExceptionMiddleware (додаток В). Цей Middleware перехоплює винятки, які можуть виникнути в процесі обробки HTTP-запитів, записує їх в журнал і відправляє клієнту відповідь у форматі JSON з відповідним статусом та інформацією про помилку.


2.4.4 Бізнес логіка


В бізнес логіці додатку використовується широкий спектр функціональності для обробки даних користувачів. Одним з ключових є використання валідаторів FluentValidation для перевірки коректності вхідних даних перед їх обробкою. Приклад відідації, що відбувається перед створенням нового дозуючого пристрою:

1. using FluentValidation;
 2. 
 3. namespace Application.Dispensers.Commands.CreateDispenser
 4. {
 5.     public class CreateDispenserCommandValidator : AbstractValidator<CreateDispenserCommand>
 6.     {
 7.         public CreateDispenserCommandValidator()
 8.         {
 9.             RuleFor(x => x.DispensorName)
10.                 .NotEmpty().WithMessage("Dispenser name is required.")
11.                 .MaximumLength(100).WithMessage("Dispenser name cannot be longer than 100 characters.");
12. 
13.             RuleFor(x => x.Location)
14.                 .NotEmpty().WithMessage("Location is required.");
15.         }
16.     }
17. }

Основним методом бізнес логіки системи є додавання лікарями призначень для пацієнтів, де зазначається інформація про тип медичного засобу його дозу, частоту прийому та період прийому медикаментів.
Серед методів бізнес логіки також можна виділити прийняття ліків. Для коректного прийняття ліків використовуються дані про рецепт, доступність препаратів у дозуючому пристрої та перевіряють кількість вже отриманих ліків для забезпечення безпеки, ефективності лікування та попередження прийому надмірної дози медичних засобів.
Для лікарів є можливість отримання статистики щодо прийому медикаментів пацієнтом. Такий аналіз здійснюється шляхом перевірки транзакцій та рецептів. Це дозволяє визначити кількість прийнятих та пропущених доз.
Для пацієнтів є можливість розрахувати прогрес прийому медичного засобу за призначенням у процентах для підвищення інтерактивності роботи та лікування.
У якості математичного метода обробки даних з розумного пристрою хочу навести обчислення одиниці виміру температури, що здійснюється на основі вхідного параметру TemperatureUnit, який вказує одиниці виміру температури (Фаренгейта або Цельсія). Це дозволяє користувачеві отримувати температурні показники у відповідній одиниці виміру.


2.4.5 Можливість адміністрування системи


Адміністраторам системи надається широкий спектр можливостей адміністрування системи. Насамперед керування користувачами, включаючи їхнє створення, видалення, перегляд та зміну ролей. Крім того, доступні інструменти для імпорту та експорту користувачів, що спрощує управління та забезпечує зручність у роботі з даними. Також адміністратори мають можливості для управління інформацією про дозуючі пристрої. Вони можуть додавати нові дозуючі пристрої, видаляти чи оновлювати інформацію про існуючі. Також система надає можливість адміністраторам додавати, видаляти та оновлювати інформацію про медикаменти. Крім того, адміністратори можуть керувати наявністю конкретних медикаментів у конкретних дозуючих пристроях.


2.4.6 Локалізація


У системі використовуються ресурси для локалізації помилок, щоб забезпечити їхнє відображення у відповідній мові для користувача.
Файли ресурсів (.resx) використовуються для зберігання текстових ресурсів у різних мовах. У цій системі підтримуються англійська мова як мова за замовченням та українська мову. Для кожної мови створено відповідний файл ресурсів з текстовими рядками для помилок.
Наприклад, є клас помилки DailyDoseAlreadyTakenException, що виникає, якщо пацієнт вже отримав денну дозу медичного засобу. Ввикористовується ресурс для повідомлення про помилку у відповідній мові. При створенні екземпляра класу помилки вказується текст помилки, який отримується з відповідного файлу ресурсів для поточної мови:

1. using Domain.Resources;
 2. 
 3. namespace Domain.Exceptions
 4. {
 5.     public class DailyDoseAlreadyTakenException : Exception
 6.     {
 7.         public DailyDoseAlreadyTakenException(): base(Resource.DailyDoseAlreadyTakenException) { }
 8.     }
 9. }

Коли ця помилка буде викинута, користувач отримає повідомлення про помилку у відповідній мові, яка була вибрана в системі.


2.4.7 Інтернаціоналізація


Інтернаціоналізація системі проявляється у забезпеченні підтримки різних одиниць виміру температури для користувачів з різних країн та регіонів. Використання двох одиниць виміру, таких як Celsius (C) та Fahrenheit (F), дозволяє користувачам обирати те, що є для них звичайним та зрозумілим.
У нашому випадку, інтернаціоналізація охоплює можливість вибору одиниці виміру температури через параметри запиту. Користувачі можуть вибрати бажану одиницю виміру, і система автоматично перетворить значення температури відповідно до обраної одиниці виміру.


2.4.8 Облік часу


У системі облік часу проводиться за стандартом часу UTC (Coordinated Universal Time) як у базі даних, так і на сервері. Це дозволяє уникнути проблем, пов'язаних з різницею у часових зонах та переходом на літні та зимові часи. Обробка відповідно часових зон відбувається на рівні клієнтського застосунку, де можна налаштувати відображення часу відповідно до місцевого часу користувача. Це дозволяє забезпечити коректне відображення часу для користувачів з різних регіонів.


2.4.9 Захист даних


Для забезпечення безпеки даних використовується протокол HTTPS для шифрування комунікації між клієнтом та сервером. Крім того, паролі користувачів зберігаються у хешованому вигляді разом із випадково згенерованим salt. Для автентифікації та авторизації користувачів використовуються JWT (JSON Web Token), що дозволяє безпечно передавати дані про автентифікацію між клієнтом та сервером і зберігати інформацію про сесію на бекенді, що підвищує безпеку та зручність управління сесіями.


2.5 Побудова діаграми прецедентів


У системі існує три актори: адміністратор, пацієнт та лікар.(див. додаток Г)


2.6 Специфікація REST


REST API містить 25 ендпоїнів, що дозволяють різним частинам системи взаємодіяти між собою. 
Специфікація REST API та опис кожного ендпоїнту наведений у таблиці 2.6.1. 
Рівні доступу:
− авторизований користувач (admin)
− системний адміністратор (patient);
− адміністратор даних (doctor).

Таблиця 2.6.1 – Специфікація REST API
Рівень доступу	Посилання на ендпоінт	HTTP-метод	Призначення
everybody	api/account/register	POST	Реєстрація користувача
everybody	/api/account/login	POST	Авторизація
admin	user/export	GET	Створення та експорт користувачів
admin	user/import	PUT	Імпорт користувачів
admin	api/user/{id}	DELETE	Видалення користувача за id
admin	api/user/change-role	POST	Зміна ролі користувача
admin	api/user	GET	Отримання усіх користувачів
admin	api/user/{id}	GET	Отримання користувача за його id
Продовження таблиці 2.6.1
admin	api/dispenser	POST	Додавання дозуючого пристрою
admin	api/dispenser/{id}	DELETE	Видалення дозуючого пристрою за id
admin	api/dispenser	PUT	Зміна місцезнаходження дозуючого пристрою
admin	api/dispenser	GET	Отримання усіх дозуючих пристроїв
doctor	api/medicine	POST	Додавання медикаменту
doctor	api/medicine/{id}	DELETE	Видалення медикаменту за id
doctor	api/medicine	GET	Отримання усіх медикаментів
doctor	api/prescription	POST	Створення призначення медикаменту для користувача
doctor	api/prescription	PUT	Редагування дози чи частоти прийому у призначенні
Продовження таблиці 2.6.1
everybody	api/prescription	GET	Отримання призначення авторизованим користувачем
admin	api/stock	POST	Додавання медикаменту до дозуючого пристрою
admin	api/stock /{id}	DELETE	Видалення медикаменту з дозуючого пристрою
patient	api/medicineintake	POST	Отримання медикаменту з дозуючого пристрою за обраним призначенням
admin	api/arduino/update-temperature	PUT	Оновлення температури дозуючого пристрою з IoT
Продовження таблиці 2.6.1
doctor	api/prescription/{id}/medicine-intake-information	GET	Отримання статистики з прийому пацієнтом медикаментів, а саме кількість прийнятих та пропущених доз медичного засобу
patient	api/prescription/{id}/percentage-of-medicine-taken	GET	Отримання прогресу прийому медичного засобу за призначенням у процентах


2.7 Побудова діаграми прецедентів


На рисунку 2.4 наведена діаграма компонентів, яка ілюструє залежності між пакетами та шарами архітектури.


Рисунок 2.4 – Діаграма компонентів


2	РОЗРОБКА ВЕБ ЧАСТИНИ ПРОЕКТУ
3.1 Опис архітектури веб частини


Для клієнтської частини проекту було використано технологію Angular. Використано TypeScript для розширення можливостей JavaScript та забезпечення сильного типізованого середовища. 
Angular дозволяє розділити функціонал додатка на окремі модулі для кращої організації та підтримки коду. У проекті були створені додаткові модулі для різних частин: авторизації та реєстрації, функціоналу адміністратора, функціоналу лікаря та функціоналу пацієнта. Сервіси використовувалися для обробки бізнес-логіки та роботи з віддаленими джерелами даних. Вони дозволяють винести загальні функції та методи в окремі компоненти, що сприяє покращенню модульності та повторному використанню коду. Інтерсептори та гуарди використовуються для обробки та контролю HTTP-запитів у системі. Вони дозволяють втручатися у процес відправлення запитів та обробки відповідей, що забезпечує додатковий контроль та безпеку додатка.Компоненти системи відображені на діаграмі компонентів Angular (додаток Д), і основний компонент проекту AppComponent керує відображенням.
Система реалізує взаємодію з трьома видами користувачів: пацієнтами, лікарями та адміністраторами. Повний функціонал, доступний для кожного з цих типів користувачів, детально описано на діаграмі прецедентів (додаток Е). 
У додатку Ж знаходиться діаграма діяльності. У цій діаграмі зображені переходи всередині системи, дані, що вводять користувачі, а також результати їх дій.
 
3.2 Реалізація веб-частини системи
3.2.1 Авторизація та управління доступом користувачів


Неавторизований користувач потрапляє на сторінку авторизації, де має можливість зареєструватися або авторизуватися:

Рисунок 3.1 – Сторінка авторизації

Рисунок 3.2 – Сторінка реєстрації

Цей компонент реалізує авторизацію за допомогою відповідного сервісу –account.service.ts (додаток К). 
Після успішної авторизації, сторінка, на яку потрапляє користувач залежить від ролі користувача. Кожен з трьох видів користувачів має різний інтерфейс та різні доступні функції. При цьому користувач одного виду не має доступ до функцій для користувача іншого виду. Це обмеження реалізується за допомогою такого інструменту, як Route Guards, що дозволяють обмежити доступ до маршрутів на основі певної умови, наприклад, лише авторизовані користувачі з певним набором прав можуть переглядати сторінку. У додатку реалізовано три види Route Guards: authGuard, adminGuard, doctorGuard, що перевіряють чи авторизован користувач та надають доступ до сторінок за роллю. authGuard наведено у додатку Л.
Для перехоплення HTTP-запитів у Angular додатку з метою автоматичного додавання JWT (JSON Web Token) до заголовків запитів використовується JwtInterceptor (додаток М). Це забезпечує автентифікацію та авторизацію користувачів під час взаємодії з сервером.

Рисунок 3.3 – Початкова сторінка для адміністратора

Рисунок 3.4 – Початкова сторінка для лікаря

Рисунок 3.5 – Початкова сторінка для пацієнта


3.2.2 Обробка помилок


У додатку клас ErrorInterceptor використовується для обробки HTTP-помилок у Angular додатку. Інтерцептор перехоплює HTTP-запити і відповіді, та обробляє помилки, що виникають під час виконання запитів. Це дозволяє централізовано обробляти помилки.
Інтерцептор виконує обробку різних статусів помилок: 400 Bad Request, 401 Unauthorized, 404 Not Found, Internal Server Error, інші помилки. При винекненні будь-якої помилки користувач може побачити її зміст на екрані.

 
Рисунок 3.6 – Помилка при введенні хибного паролю

Код класу ErrorInterceptor:

1. import { Injectable } from '@angular/core';
 2. import {
 3.   HttpRequest,
 4.   HttpHandler,
 5.   HttpEvent,
 6.   HttpInterceptor,
 7.   HttpErrorResponse
 8. } from '@angular/common/http';
 9. import { Observable, catchError } from 'rxjs';
10. import { Router } from '@angular/router';
11. import { ToastrService } from 'ngx-toastr';
12. 
13. @Injectable()
14. export class ErrorInterceptor implements HttpInterceptor {
15. 
16.   constructor(private router: Router, private toastr: ToastrService) {}
17. 
18.   intercept(request: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> {
19.     return next.handle(request).pipe(
20.       catchError((error: HttpErrorResponse) => {
21.         if(error){
22. 
23.           switch(error.status){
24.             case 400:
25.               if(error.error.errors){
26.                 const modelStatusErrors = [];
27.                 for(const key in error.error.errors){
28.                   if(error.error.errors[key]){
29.                     modelStatusErrors.push(error.error.errors[key])
30.                   }
31.                 }
32.                 throw modelStatusErrors.flat();
33.               }
34.               else{
35.                 this.toastr.error(error.error, error.status.toString())
36.               }
37.               break;
38.             case 401:
39.               this.toastr.error('Unauthorised', error.status.toString());
40.               break;
41.             case 404:
42.               this.router.navigateByUrl('/not-found');
43.               break;
44.             case 500:
45.               this.toastr.error(error.error.message);
46.               break;
47.             default:
48.               this.toastr.error('Something unexpected');
49.               console.log(error);
50.           }
51.         }
52.         throw error;
53.       })
54.     )
55.   }
56. }
 
3.2.3 Можливість адміністрування системи


Можливість адміністрування реалізована для користувача з роллю адміністратора. Він має доступ до сторінок адміністрування дозуючих пристроїв, медичних засобів, користувачів та зберігання медичних засобів у дозуючих пристроях. На цих сторінках адміністратор має доступ до таких функцій, як: додавання нового запису, видалення існуючого запису чи його зміна. 
Рисунок 3.5 – Сторінка адміністрування дозуючих пристроїв 
 

Рисунок 3.6 – Сторінка адміністрування користувачів  

Рисунок 3.7 – Сторінка адміністрування медичних засобів  

Рисунок 3.8 – Сторінка адміністрування зберігання медичних засобів у дозуючих пристроях   

Для додавання нового запису чи редагування існуючого адміністратору надаються діалогові вікна для введення даних.

Рисунок 3.9 – Створення нового дозуючого пристрою

Рисунок 3.10 – Зміна ролі користувача   

Для створення бекапу даних є можливість збереження користувачів у файл з розширенням .xlsx та завантаження користувачів з такого файлу у базу даних. Для цього на сторінці адміністрування користувачів можна побачити відповідні кнопки.

Рисунок 3.11 – Можливість імпорту та експорту


3.2.4 Інтернаціоналізація


Інтернаціоналізація у системі проявляється у забезпеченні підтримки різних одиниць виміру температури для користувачів з різних країн та регіонів. Використання двох одиниць виміру, таких як Celsius (C) та Fahrenheit (F), дозволяє користувачам обирати те, що є для них звичайним та зрозумілим. 
У нашому випадку, інтернаціоналізація охоплює можливість вибору одиниці виміру температури у дозуючому пристрої, що дозволяє контролювати температуру зберігання медичних засобів, через чекбокс. 

Рисунок 3.12 – Температура представлена у градусах по Цельсію

Рисунок 3.12 – Температура представлена у градусах по Фаренгейту


3.2.5 Бізнес логіка


Бізнес логіка додатка розподіляється на бізнес логіку для лікарів та пацієнтів. Лікарі мають можливість передивлятися сторінки пацієнтів, де зазначена основна інформація про пацієнта та наведено список призначень, що вже виписані пацієнту.

Рисунок 3.14 – Сторінка з інформацією про пацієнта

На цій же сторінці лікар має можливість додати нове призначення, до списку призначень пацієнта.

Рисунок 3.14 – Створення нового призначення для пацієнта

Лікар також може отримати більш розгорнуту інформацію про процес отримання пацієнтом ліків, а сама кількість прийнятих та пропущених доз. 

Рисунок 3.16 – Інформація про прийом ліків пацієнтом

Пацієнти при авторизації отримують перелік своїх призначень з індикатором процесу, що у відсотках показує прогрес прийому ліків за призначенням.

Рисунок 3.17 – Перелік призначень пацієнта

Крім того, пацієнти можуть отримувати перелік медичних засобів, які отримують на даний момент з метою ознайомлення з їх можливими протипоказаннями та побічними ефектами.

Рисунок 3.18 – Перелік медичних засобів пацієнта


3.2.6 Локалізація


Цей пункт передбачає використання модулю TranslateModule для забезпечення локалізації ресурсів у відповідній мові для користувача. TranslateModule дозволяє легко перекладати текстові рядки у програмі на різні мови за допомогою конфігурації. Після включення цього модулю, рядки, які потребують локалізації, можуть бути легко ідентифіковані та перекладені. Це забезпечує зручне та ефективне використання програми користувачами з різних культурних та мовних середовищ.

 
Рисунок 3.19 – Англійська версія додатку
 
Рисунок 3.20 – Українська версія додатку


3.2.7 Облік часу


У проекті було вирішено обробляти час на стороні клієнта. Оскільки дані часу зберігаються на сервері у форматі UTC, на клієнтському застосунку використовується MomentModule для обчислення локального часу користувача. 
 
4 РОЗРОБКА МОБІЛЬНОЇ ЧАСТИНИ ПРОЕКТУ
4.1 Опис архітектури мобільної частини


Для мобільної частини проекту використано мову програмування C# та платформу .NET Multi-Platform App UI (.NET MAUI) для створення мобільних додатків. Проект побудовано на основі принципів Domain-Driven Design (DDD), що дозволило чітко розділити відповідальність між різними компонентами системи, забезпечуючи високу підтримуваність та можливість розширення коду.
Для організації HTTP-запитів у проекті використовується клас HttpClient, який забезпечує функціональність для відправлення запитів до веб-серверів і отримання відповідей. Використання HttpClient для організації HTTP-запитів у .NET MAUI проекті включає створення запиту, встановлення необхідних параметрів, відправку запиту, обробку відповіді та збереження результатів. Це забезпечує ефективну взаємодію мобільного застосунку з веб-сервером для виконання різних операцій.
Мобільний застосунок передбачає використання вже зареєстрованим користувачем з роллю пацієнт. У цій частині системи реалізується бізнес логіка прийому медичних засобів пацієнтом з відповідного дозуючого пристрою.
 
4.2 Реалізація мобільної частини системи
4.2.1 Авторизація та управління доступом користувачів


Першим чином користувач потрапляє на сторінку авторизації.

 
Рисунок 4.1 – Сторінка авторизації

Цей компонент реалізує авторизацію за допомогою відповідного сервісу – UserService (додаток Н).
Після успішної авторизації сервер повертає JWT токен, який зберігається в конфігурації додатку для подальшого використання.

4.2.2 Бізнес логіка


Після успішної авторизації, сторінка, на яку потрапляє користувач – перелік його медичних призначень.

Рисунок 4.2 – Сторінка з переліком призначень авторизованого пацієнта

На цьому етапі пацієнт має можливість обрати який саме медичний засіб із своїх призначень він бажає отримати, а також має можливість вийти із системи за допомогою кнопки Logout. 
Після вибору призначення за яким користувач бажає отримати ліки він потрапляє на сторінку, де представлені усі дозуючі пристрої, у яких знаходиться бажаний медичний засіб. На цій сторінці, після вибору дозуючого пристрою, користувач має виконати отримання препарату за допомогою натискання кнопки Get Pill. Також можливе повернення до списку призначень з метою вибору іншого з них.

Рисунок 4.3 – Сторінка з доступними дозуючими пристроями

Завдяки методам бізнес логіки, що реалізовані у клієнтському застосунку є можливість відслідкувати прийом медичних засобів пацієнтом. У веб частині системи користувач може також потрапити  на список своїх призначень, але там він має функції лише для моніторингу прийому, що відбувається завдяки мобільному застосунку. 
Отже, при виборі списку своїх медичних засобів пацієнт може бачити назву медичного засобу, його дозу, кількість обов’язкових прийомів на день, дати початку та кінця отримання ліків за кожноим призначенням, а і останньому стовпчику процент вже прийнятих ліків на даний момент. Нижче на рисунках представлено прогрес за призначенням до та після прийому ліків завдяки мобільній частині системи.

Рисунок 4.4 – Сторінка з клієнтської частини з прогресом відстеження прийому медичних засобів для пацієнта до прийому ліків у мобільному застосунку

Рисунок 4.5 – Сторінка з клієнтської частини з прогресом відстеження прийому медичних засобів для пацієнта після прийому ліків 


4.2.3 Локалізація


З метою локалізації мобільної частини було використано файли ресурсів. В залежності від конфігурації пристрою, користувачу доступна англійська чи українська версію застосунку.
 

ВИСНОВКИ


В рамках курсового проектування було розроблено програмну система для для автоматизованого моніторингу та керування прийомом медикаментів. Для розробки серверної частини було використано технології ASP.NET Core Web API, систему управління базами даних PostgreSQL. Веб-додаток базується на технології Angular, з використанням. Мобільний застосунок розроблений на мові програмування C# та платформs .NET Multi-Platform App UI (.NET MAUI) для створення мобільних додатків. В ході роботи були розроблені серверна частина системи, веб-додаток та мобільний застосунок. Розроблена система реалізує заявлену у Vision&Scope (додаток Н) функціональність та бізнес логіку. Система може бути надалі розширена та доповнена функціоналом.
 

ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1. angular-moment. npm. URL: https://www.npmjs.com/package/angular-moment (date of access: 13.06.2024).
2. Automatic Pill Dispenser - How the Hero Dispenser Works!. Hero. URL: https://herohealth.com/our-product/ (date of access: 13.06.2024).
3. Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides. Design Patterns. Elements of Reusable Object-oriented Software. Addsion Wesley Longman, printed in India by Eastern Press, 1999. [2, с. 139]
4. medDispense Classic Automated Dispensing Cabinets. Healthcare Solutions | Medical Carts & Medication Management. URL: https://www.touchpointmed.com/product/meddispense-classic-automated-dispensing-cabinets (date of access: 13.06.2024).
 

ДОДАТОК А
Код репозиторію дозуючих пристроїв


1. using Application.Dispensers.Commands.CreateDispenser;
 2. using Application.Dispensers.Commands.DeleteDispenser;
 3. using Application.Dispensers.Commands.UpdateDispenser;
 4. using Application.Dispensers.Commands.UpdateDispenserTempereture;
 5. using Application.Dispensers.Queries.GetDispensers;
 6. using Application.Interfaces;
 7. using Application.MedicineStocks.Commands.UpdateMedicineStock;
 8. using AutoMapper;
 9. using Domain.Entities;
10. using Domain.Enums;
11. using Domain.Exceptions;
12. using Infrastructure.Data;
13. using Infrastructure.Hubs;
14. using Microsoft.AspNetCore.Http.HttpResults;
15. using Microsoft.AspNetCore.SignalR;
16. using Microsoft.EntityFrameworkCore;
17. 
18. namespace Infrastructure.Repositories;
19. 
20. public class DispenserRipository : Repository<Dispenser>, IDispenserRepository
21. {
22.     private readonly IMapper _mapper;
23. 
24.     private readonly IUnitOfWork _unitOfWork;
25. 
26.     private readonly IHubContext<NotificationHub, INotificationHub> _notificationHub;
27. 
28.     private const double THRESHOLD_TEMPERATURE = 26;
29. 
30.     public DispenserRipository(AppDbContext context, IMapper mapper, IUnitOfWork unitOfWork, IHubContext<NotificationHub, INotificationHub> notificationHub) : base(context)
31.     {
32.         _unitOfWork = unitOfWork;
33.         _mapper = mapper;
34.         _notificationHub = notificationHub;
35.     }
36. 
37.     public async Task<int> CreateDispenser(CreateDispenserCommand request, CancellationToken cancellationToken)
38.     {
39.         var dispenser = await _context.Dispensers.FirstOrDefaultAsync(x => x.DispensorName == request.DispensorName && x.Location == request.Location);
40.         if (dispenser is not null)
41.         {
42.             throw new DispenserAlreadyExistsException();
43.         }
44.         var newDispenser = _mapper.Map<Dispenser>(request);
45.         await base.Create(newDispenser);
46.         await _unitOfWork.SaveChanges(cancellationToken);
47.         return newDispenser.Id;
48.     }
49. 
50.     public async Task<int> DeleteDispenser(DeleteDispenserCommand request, CancellationToken cancellationToken)
51.     {
52.         var removedDispenser = await _context.Dispensers.FirstOrDefaultAsync(x => x.Id == request.Id);
53.         if (removedDispenser is null)
54.         {
55.             throw new DispenserNotFoundException();
56.         }
57.         await base.Delete(removedDispenser);
58.         return removedDispenser.Id;
59.     }
60. 
61.     public async Task<List<Dispenser>> GetAllAsync(GetDispensersQuery request, CancellationToken cancellationToken)
62.     {
63.         var dispensers = await base.GetAllAsync(cancellationToken);
64. 
65.         if (request.TemperatureUnit == "F")
66.         {
67.             foreach (var dispenser in dispensers)
68.             {
69.                 dispenser.StorageTemperature = ConvertToFahrenheit(dispenser.StorageTemperature);
70.             }
71.         }
72. 
73.         return dispensers;
74.     }
75. 
76.     private double ConvertToFahrenheit(double celsiusTemperature)
77.     {
78.         return celsiusTemperature * 9 / 5 + 32;
79.     }
80. 
81.     public async Task UpdateLocation(UpdateDispenserLocationCommand request, CancellationToken cancellationToken)
82.     {
83.         var dispenser = await _context.Dispensers.FirstOrDefaultAsync(x => x.Id == request.Id);
84.         if (dispenser is null)
85.         {
86.             throw new DispenserNotFoundException();
87.         }
88.         else
89.         {
90.             dispenser.Location = request.Location;
91.             await base.Update(dispenser, cancellationToken);
92.         }
93.     }
94. 
95.     public async Task UpdateTemperature(UpdateDispenserTemperetureCommand request, CancellationToken cancellationToken)
96.     {
97.         var dispenser = await _context.Dispensers.FirstOrDefaultAsync(x => x.Id == request.Id);
98.         if (dispenser is null)
99.         {
100.            throw new DispenserNotFoundException();
101.        }
102.        else
103.        {
104.            dispenser.StorageTemperature = request.StorageTemperature;
105.            await base.Update(dispenser, cancellationToken);
106. 
107.            if (request.StorageTemperature > THRESHOLD_TEMPERATURE)
108.            {
109.                await _notificationHub.Clients.All.SendNotification("Temperature exceeded!");
110.            }
111.        }
112.    }
113.}
 
ДОДАТОК Б
Код хендлера команди створення дозуючого пристрою


1. using Application.Interfaces;
 2. using AutoMapper;
 3. using Domain.Entities;
 4. using MediatR;
 5. 
 6. namespace Application.Dispensers.Commands.CreateDispenser
 7. {
 8.     public class CreateDispenserCommandHandler : IRequestHandler<CreateDispenserCommand, int>
 9.     {
10.         private readonly IDispenserRepository _dispenserRipository;
11.         private readonly IMapper _mapper;
12. 
13.         public CreateDispenserCommandHandler(IDispenserRepository dispenserRipository, IMapper mapper)
14.         {
15.             _dispenserRipository = dispenserRipository;
16.             _mapper = mapper;
17.         }
18. 
19.         public async Task<int> Handle(CreateDispenserCommand request, CancellationToken cancellationToken)
20.         {
21.             var newDispenserId = await _dispenserRipository.CreateDispenser(request, cancellationToken);
22.             return newDispenserId;
23.         }
24.     }
25. }
Код хендлера запиту отримання всіх дозуючих пристроїв
1. using Application.Interfaces;
 2. using Application.Users.Queries.GetUser;
 3. using AutoMapper;
 4. using MediatR;
 5. 
 6. namespace Application.Dispensers.Queries.GetDispensers
 7. {
 8.     public class GetDispensersQueryHandler : IRequestHandler<GetDispensersQuery, List<DispenserResponse>>
 9.     {
10.         private readonly IDispenserRepository _dispenserRepository;
11.         private readonly IMapper _mapper;
12. 
13.         public GetDispensersQueryHandler(IDispenserRepository dispenserRepository, IMapper mapper)
14.         {
15.             _dispenserRepository = dispenserRepository;
16.             _mapper = mapper;
17.         }
18. 
19.         public async Task<List<DispenserResponse>> Handle(GetDispensersQuery request, CancellationToken cancellationToken)
20.         {
21.             var dispensers = await _dispenserRepository.GetAllAsync(request, cancellationToken);
22.             return _mapper.Map<List<DispenserResponse>>(dispensers);
23.         }
24.     }
25. }
 
ДОДАТОК В
Код класу  ExceptionMiddleware


1. using System.Net;
 2. using System.Text.Json;
 3. using Domain.Exceptions;
 4. 
 5. namespace Presentation.Middleware
 6. {
 7.     public class ExceptionMiddleware
 8.     {
 9.         private readonly RequestDelegate _next;
10.         private readonly ILogger<ExceptionMiddleware> _logger;
11.         private readonly IHostEnvironment _env;
12.         
13.         public ExceptionMiddleware(RequestDelegate next, ILogger<ExceptionMiddleware> logger, IHostEnvironment env)
14.         {
15.             _env = env;
16.             _logger = logger;
17.             _next = next;
18.         }
19. 
20.         public async Task InvokeAsync(HttpContext context)
21.         {
22.             try
23.             {
24.                 await _next(context);
25.             }
26.             catch (Exception ex)
27.             {
28.                 _logger.LogError(ex, ex.Message);
29.                 context.Response.ContentType = "application/json";
30.                 context.Response.StatusCode = (int)HttpStatusCode.InternalServerError;
31. 
32.                 var responce = _env.IsDevelopment()
33.                     ? new ApiException(context.Response.StatusCode, ex.Message, ex.StackTrace?.ToString())
34.                     : new ApiException(context.Response.StatusCode, ex.Message, "Internal server error");
35. 
36.                 var options = new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase };
37.                 var json = JsonSerializer.Serialize(responce, options);
38.                 await context.Response.WriteAsync(json); 
ДОДАТОК Г
Діаграма прецидентів серверної частини


 
Рисунок Г.1 - Діаграма прецидентів
 
ДОДАТОК Д
Діаграма компонентів веб частини


 
 Рисунок Д.1 – Діаграма компонентів веб частини
ДОДАТОК Е
Діаграма прецедентів веб частини


 
Рисунок Е.1 – Діаграма прецедентів веб частини
ДОДАТОК Ж
Діаграма діяльності веб частини



Рисунок Ж.1 – Діаграма діяльності веб частини 
ДОДАТОК К
Код файлу AccountService


1. import { Injectable } from '@angular/core';
 2. import { Router } from '@angular/router';
 3. import { HttpClient } from '@angular/common/http';
 4. import { User } from '../_models/user';
 5. import { BehaviorSubject, Observable, map } from 'rxjs';
 6. import { environment } from 'src/environments/environment.development';
 7. 
 8. @Injectable({
 9.   providedIn: 'root'
10. })
11. export class AccountService {
12.   private userSubject: BehaviorSubject<User | null>;
13.   public user: Observable<User | null>;
14. 
15.   constructor(private router: Router, private http: HttpClient) { 
16.     // Initialize the userSubject with the user from localStorage (if available)
17.     this.userSubject = new BehaviorSubject(JSON.parse(localStorage.getItem('user')!));
18.     this.user = this.userSubject.asObservable();
19.   }
20. 
21.   // Getter to access the current user value
22.   public get userValue() {
23.     return this.userSubject.value;
24.   }
25. 
26.   /**
27.    * Logs in the user by making a POST request to the API.
28.    * @param email - The user's email address.
29.    * @param password - The user's password.
30.    * @returns An Observable containing the user data.
31.    */
32.   login(email: string, password: string) {
33.     return this.http.post<any>(`${environment.apiUrl}/api/account/login`, { email, password })
34.       .pipe(
35.         map(user => {
36.           // Store user details in localStorage and update the userSubject
37.           localStorage.setItem('user', JSON.stringify(user));
38.           this.userSubject.next(user);
39.           return user;
40.         })
41.       );
42.   }
43. 
44.   /**
45.    * Registers a new user by making a POST request to the API.
46.    * @param name - The user's first name.
47.    * @param surname - The user's last name.
48.    * @param age - The user's age.
49.    * @param email - The user's email address.
50.    * @param password - The user's password.
51.    * @returns An Observable containing the user data.
52.    */
53.   register(name: string, surname: string, age: number, email: string, password: string) {
54.     return this.http.post<any>(`${environment.apiUrl}/api/account/register`, { name, surname, age, email, password })
55.       .pipe(
56.         map(user => {
57.           // Store user details in localStorage and update the userSubject
58.           localStorage.setItem('user', JSON.stringify(user));
59.           this.userSubject.next(user);
60.           return user;
61.         })
62.       );
63.   }
64. 
65.   /**
66.    * Logs out the user by removing the user data from localStorage and resetting the userSubject.
67.    * Also navigates the user to the login page.
68.    */
69.   logout() {
70.     localStorage.removeItem('user');
71.     this.userSubject.next(null);
72.     this.router.navigate(['/account/login']);
73.   }
74. 
75.   /**
76.    * Gets the role of the currently logged-in user.
77.    * @returns The user's role if available, otherwise undefined.
78.    */
79.   getRole() {
80.     const userString = localStorage.getItem('user');
81.     if (userString) {
82.       const user = JSON.parse(userString);
83.       return user.Role;
84.     }
85.   }
86. 
87.   /**
88.    * Gets the name of the currently logged-in user.
89.    * @returns The user's name if available, otherwise undefined.
90.    */
91.   getName() {
92.     const userString = localStorage.getItem('user');
93.     if (userString) {
94.       const user = JSON.parse(userString);
95.       return user.Name;
96.     }
97.   }
98. }
 
ДОДАТОК Л
Код файлу authGuard


1. import { inject } from '@angular/core';
 2. import { CanActivateFn } from '@angular/router';
 3. import { AccountService } from '../_services/account.service';
 4. import { ToastrService } from 'ngx-toastr';
 5. import { map } from 'rxjs';
 6. 
 7. export const authGuard: CanActivateFn = (route, state) => {
 8.   const accountService = inject(AccountService);
 9.   const toastr = inject(ToastrService);
10. 
11.   return accountService.user.pipe(
12.     map(user => {
13.       if(user) return true;
14.       else {
15.         toastr.error('No access!');
16.         return false;
17.       }
18.     })
19.   )
20. };
 
ДОДАТОК М
Код файлу JwtInterceptor


1. import { Injectable } from '@angular/core';
 2. import {
 3.   HttpRequest,
 4.   HttpHandler,
 5.   HttpEvent,
 6.   HttpInterceptor
 7. } from '@angular/common/http';
 8. import { Observable } from 'rxjs';
 9. 
10. @Injectable()
11. export class JwtInterceptor implements HttpInterceptor {
12. 
13.   constructor() {}
14. 
15.   intercept(request: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> {
16.     const user = localStorage.getItem('user');
17.     let token = null;
18. 
19.     if (user) {
20.       try {
21.         const userObj = JSON.parse(user);
22.         token = userObj?.Token;
23.       } catch (error) {
24.         console.error('Error parsing user from localStorage', error);
25.       }
26.     }
27.     
28.     if (token) {
29.       request = request.clone({
30.         setHeaders: {
31.           Authorization: `Bearer ${token}`
32.         }
33.       });
34.     }
35.     return next.handle(request);
36.   }
37. }

 
ДОДАТОК Н
Код файлу UserService


using System.Net.Http.Json;
using Application.Configurations;
using Application.Interfaces;
using Application.Users.Commands;
using Domain.Entities;

namespace Infrastructure.Services;

public class UserService : IUserService
{
    private readonly TokenConfiguration _tokenConfiguration;

    public UserService(TokenConfiguration tokenConfiguration)
    {
        _tokenConfiguration = tokenConfiguration;
    }

    public async Task Login(LoginCommand request)
    {
        var httpClient = new HttpClient()
        {
            BaseAddress = new Uri("http://10.0.2.2:8080/api/")
        };

        var httpRequestMessage = new HttpRequestMessage()
        {
            Content = JsonContent.Create(request),
            Method = HttpMethod.Post,
            RequestUri = new Uri("account/login", UriKind.Relative)
        };
        
        var response = await httpClient.SendAsync(httpRequestMessage);
        var auth = await response.Content.ReadFromJsonAsync<Auth>();
        _tokenConfiguration.Token = auth.Token;
    }
}
